import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'core'))

import unittest
import numpy as np
from berlekamp_massey import berlekamp_massey

class TestBerlekampMassey(unittest.TestCase):
    """
    Test cases for the Berlekamp-Massey algorithm implementation.
    Tests both known sequences and edge cases.
    """
    
    def test_trivial_sequence(self):
        """Test with all-zero sequence"""
        sequence = [0, 0, 0, 0, 0]
        poly = berlekamp_massey.find_minimal_polynomial(sequence)
        self.assertEqual(poly, [1], "All-zero sequence should have minimal polynomial [1]")
    
    def test_constant_sequence(self):
        """Test with all-ones sequence"""
        sequence = [1, 1, 1, 1, 1]
        poly = berlekamp_massey.find_minimal_polynomial(sequence)
        # For all-ones, minimal polynomial should be [1, 1] representing 1 + x
        self.assertEqual(poly, [1, 1], "All-ones sequence should have minimal polynomial [1, 1]")
    
    def test_alternating_sequence(self):
        """Test with alternating 0,1,0,1,... sequence"""
        sequence = [0, 1, 0, 1, 0, 1, 0, 1]
        poly = berlekamp_massey.find_minimal_polynomial(sequence)
        # Alternating sequence has minimal polynomial [1, 0, 1] representing 1 + x²
        expected = [1, 0, 1]
        self.assertEqual(poly, expected, f"Alternating sequence should have polynomial {expected}")
    
    def test_fibonacci_mod2(self):
        """Test with Fibonacci sequence mod 2: [1,1,0,1,1,0,1,1,0,...]"""
        sequence = [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]
        poly = berlekamp_massey.find_minimal_polynomial(sequence)
        # Fibonacci mod 2 has period 3, minimal polynomial should be [1, 1, 1]
        expected = [1, 1, 1]
        self.assertEqual(poly, expected, f"Fibonacci mod 2 should have polynomial {expected}")
    
    def test_known_lfsr_sequence(self):
        """Test with a known LFSR sequence"""
        # Sequence generated by 1 + x + x³ (polynomial [1, 1, 0, 1])
        # Starting with [1, 0, 0] gives: 1,0,0,1,0,1,1,1,0,0,1,0,1,1,...
        sequence = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1]
        poly = berlekamp_massey.find_minimal_polynomial(sequence)
        expected = [1, 1, 0, 1]
        self.assertEqual(poly, expected, f"Known LFSR should have polynomial {expected}")
    
    def test_single_element(self):
        """Test with single element sequences"""
        poly0 = berlekamp_massey.find_minimal_polynomial([0])
        poly1 = berlekamp_massey.find_minimal_polynomial([1])
        self.assertEqual(poly0, [1], "Single zero should give [1]")
        self.assertEqual(poly1, [1, 1], "Single one should give [1, 1]")
    
    def test_empty_sequence(self):
        """Test with empty sequence"""
        poly = berlekamp_massey.find_minimal_polynomial([])
        self.assertEqual(poly, [1], "Empty sequence should give [1]")
    
    def test_polynomial_annihilation(self):
        """Test that the returned polynomial actually annihilates the sequence"""
        sequences = [
            [1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
            [0, 1, 1, 0, 1, 0, 0, 1, 1, 0],
            [1, 1, 1, 0, 0, 1, 0, 1, 0, 0]
        ]
        
        for seq in sequences:
            with self.subTest(sequence=seq):
                poly = berlekamp_massey.find_minimal_polynomial(seq)
                self._verify_annihilation(seq, poly)
    
    def _verify_annihilation(self, sequence, poly):
        """Verify that the polynomial annihilates the sequence"""
        L = len(poly) - 1  # degree of polynomial
        if L == 0:  # trivial polynomial
            return
            
        # Check annihilation: sum_{i=0}^L poly[i] * seq[k+i] = 0 for all valid k
        for k in range(len(sequence) - L):
            acc = 0
            for i, coeff in enumerate(poly):
                if coeff and k + i < len(sequence):
                    acc ^= sequence[k + i]
            self.assertEqual(acc, 0, 
                f"Polynomial {poly} does not annihilate sequence {sequence} at position {k}")
    
    def test_random_sequences(self):
        """Test with random binary sequences"""
        np.random.seed(42)  # for reproducibility
        
        for length in [5, 8, 12, 16]:
            with self.subTest(length=length):
                sequence = np.random.randint(0, 2, length).tolist()
                poly = berlekamp_massey.find_minimal_polynomial(sequence)
                
                # Verify the polynomial is valid
                self.assertIsInstance(poly, list, "Result should be a list")
                self.assertTrue(len(poly) >= 1, "Polynomial should have at least one coefficient")
                self.assertEqual(poly[0], 1, "First coefficient should always be 1")
                
                # Verify annihilation property
                self._verify_annihilation(sequence, poly)

if __name__ == '__main__':
    unittest.main()
